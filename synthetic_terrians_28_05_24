//#include "C:/dev/CGAL-4.8/examples/Sample-Test1/pch.h"
#include <fstream>
#include <sstream>
#include <string>
#define _USE_MATH_DEFINES
#include <math.h>
#include <CGAL/Exact_predicates_inexact_constructions_kernel.h>
#include <CGAL/Projection_traits_xy_3.h>
#include <CGAL/Delaunay_triangulation_2.h>
#include <CGAL/Triangulation_2.h>
#include <CGAL/Triangulation_vertex_base_with_info_2.h>
#include <vector>
#include <random>
#include <CGAL/point_generators_2.h>
#include <CGAL/Random.h>
#include <CGAL/Polygon_2.h>
#include <cstdlib> 
#include <ctime>
#include <assert.h>

using namespace std;


typedef CGAL::Exact_predicates_inexact_constructions_kernel            Kernel;
typedef CGAL::Projection_traits_xy_3<Kernel> Gt;
typedef CGAL::Triangulation_vertex_base_with_info_2< unsigned int, Gt > Vb;
typedef CGAL::Triangulation_data_structure_2<Vb>                       Tds;
typedef CGAL::Delaunay_triangulation_2<Gt, Tds>                    Delaunay;
typedef CGAL::Polygon_2<Kernel>                                     Polygon_2;

typedef Kernel::Point_2                                                  Point_2;

typedef Kernel::Iso_rectangle_2                                  Rectangle_2;
typedef std::vector<Point_2>                                        Container;
typedef CGAL::Random_points_in_square_2<Point_2>                  Point_i_generator;
typedef CGAL::Random_points_on_square_2<Point_2>                  Point_o_generator;

typedef Kernel::Point_3                                                Point;

const int n = 3; //we work in 3D
vector <double> z_axis = { 0,0,1 };   //the definition of the z-axis
double converter = 180 / M_PI; // converts radians to angles and vice versa

class plane //a class that stores the crucial figures in terms of computing the orientation
{

private:
	Point first_point;            //the first point of a triangle
	Point second_point;            //the second point of a triangle
	Point third_point;            //the third_point of a triangle

	vector <double> first_vec;            //the first edge of a triangle
	vector <double> second_vec;			//the second edge of a triangle
	vector <double> third_vec;			//the third edge of a triangle
	vector <double> normal_vec;			//normal vector of a triangle
	vector <double> directional;			//the projection of the normal vector onto the horizontal plane
	//vector <double> z_axis = { 0,0,1 };   //the definition of the z-axis
	vector <double> dip_vec;
	double doc;						//a variable that contains the collinearity coefficient
	bool lin_dependence;		    //a bool variable to check to answer whether points are (too) collinear
	string dip_degrees;             //a text variable to store the dip angle
	string azimuth_degrees;         //a text variable to store the dip direction

public:
	static const int n = 3;			//the dimension of vectors
	const double ex = 2;			//we introduce the restriction of collinearity - it should be between 0 and 1 to actually work
	
	double dip_azimuth(vector<double> normal, int n = 2) //a function that computes the dip azimuth
	{
		double angle = atan2(normal[1], normal[0]);
		angle = angle * converter;
		if (angle < 0)
		{
			return angle + 360;
		}
		else
		{
			return angle;
		}
	}

	

	double dip_angle( vector<double>z_axis, vector<double> normal_v) //function that computes the dip angle
	{
		double numerator = dot_product(z_axis, normal_v);
		if (numerator >= 1.0) {
			return 0;
		}
		else {
			return acos(numerator) * converter;
		}
	}

	static double dot_product(vector<double> vector_1, vector<double> vector_2, int n = 3) //function that computes the dot product of vectors
	{
		double product = 0;
		for (int i = 0; i < n; i++)
		{
			product += vector_1[i] * vector_2[i];
		}
		return product;
	}

	bool dependence(vector<double> v1, vector<double> v2, vector<double> v3) //function that checks whether the points are collinear
	{
		double len_v1 = length(v1);
		double len_v2 = length(v2);
		double len_v3 = length(v3);
		double lengths[n] = { len_v1, len_v2, len_v3 };

		sort(lengths, lengths + n);
		this->doc = lengths[2] / (lengths[0] + lengths[1]);
		int k = 0;
		for (int i = 0; i < n; i++)
		{
			if (lengths[i] == 0)
			{
				k += 1;
			}
		}
		if (k != 0)
		{
			return true;
		}
		else
		{
			if (doc > ex)
			{
				return true;
			}
			else
			{
				return false;
			}
		}
	}

	static double length(vector<double> line_vector, int n = 3) //function that computes the length of a vector
	{
		double vector_length = sqrt(pow(line_vector[0], 2) + pow(line_vector[1], 2) + pow(line_vector[2], 2));
		return vector_length;
	}

	vector <string> center() //function that computes the geometrical centre of a triangle, usuwane
	{
		double x = (first_point.x() + second_point.x() + third_point.x()) / (3.0);
		double y = (first_point.y() + second_point.y() + third_point.y()) / (3.0);
		double z = (first_point.z() + second_point.z() + third_point.z()) / (3.0);
		vector<string> napis{ to_string(x), to_string(y), to_string(z) };
		return napis;
	}

	plane(Point point_1, Point point_2, Point point_3) //the class constructor
	{

		this->first_point = Point(point_1.x(), point_1.y(), point_1.z());
		this->second_point = Point(point_2.x(), point_2.y(), point_2.z());
		this->third_point = Point(point_3.x(), point_3.y(), point_3.z());

		vector<double>  first_try = { point_2.x() - point_1.x(), point_2.y() - point_1.y(), point_2.z() - point_1.z() };
		vector<double>  second_try = { point_3.x() - point_1.x(), point_3.y() - point_1.y(), point_3.z() - point_1.z() };
		vector<double>  third_try = { point_3.x() - point_2.x(), point_3.y() - point_2.y(), point_3.z() - point_2.z() };

		bool test = dependence(first_try, second_try, third_try);
		if (test == true)
		{
			lin_dependence = true;
			this->first_vec = { -99,-99,-99 };
			this->second_vec = { -99,-99,-99 };
			this->third_vec = {-99,-99,-99};
			this->normal_vec = { -99,-99,-99 };
			this->dip_vec = { -99, -99, -99 };
			measure();
		}
		else
		{
			lin_dependence = false;
			for (int i = 0; i < n; i++)
			{
				this->first_vec.push_back(first_try[i]);
				this->second_vec.push_back(second_try[i]);
				this->third_vec.push_back(third_try[i]);
			}
			normal_vec.push_back(first_vec[1] * second_vec[2] - second_vec[1] * first_vec[2]);
			normal_vec.push_back(first_vec[2] * second_vec[0] - second_vec[2] * first_vec[0]);
			normal_vec.push_back(first_vec[0] * second_vec[1] - second_vec[0] * first_vec[1]);

			if (normal_vec[2] < 0) {
				normal_vec[0] *= -1;
				normal_vec[1] *= -1;
				normal_vec[2] *= -1;
			}

			double normal_length = length(normal_vec);
			normal_vec[0] = normal_vec[0] / normal_length;
			normal_vec[1] = normal_vec[1] / normal_length;
			normal_vec[2] = normal_vec[2] / normal_length;

			dip_vec.push_back(cos(dip_angle(z_axis, normal_vec) / converter) * cos(dip_azimuth(normal_vec) / converter));
			dip_vec.push_back(cos(dip_angle(z_axis, normal_vec) / converter) * sin(dip_azimuth(normal_vec) / converter));
			dip_vec.push_back(-sin(dip_angle(z_axis, normal_vec) / converter));

			measure(); //setting dip_degrees and azimuth_degrees
		}
	}
	

	void measure()//function that supplies orientation results also for singularities
	{
		if (lin_dependence) // result for collinear points
		{
			this->azimuth_degrees = ("LT");
			this->dip_degrees = ("LT");
		//	return (dip_degrees + ";" + azimuth_degrees);
		}
		else if (normal_vec[0] == 0 && normal_vec[1] == 0 && normal_vec[2] != 0) //result for a horizontal triangle
		{
			this->dip_degrees = "0";
			this->azimuth_degrees = ("x");
		//	return (dip_degrees + ";" + azimuth_degrees);
		}
		else if (normal_vec[2] == 0) //result for a vertical triangle
		{
			this->dip_degrees = "90";
			this->azimuth_degrees = to_string(dip_azimuth(normal_vec));
		//	return dip_degrees + ";" + azimuth_degrees;
		}
		else //a normal case (no singularities)
		{
			double dipping_angle = dip_angle(z_axis, normal_vec);
			this->dip_degrees = to_string(dipping_angle);
			this->azimuth_degrees = to_string(dip_azimuth(normal_vec));
		//	return dip_degrees + ";" + azimuth_degrees;
		}
	}


	string get_dip_angle() {

		return this->dip_degrees;
	}

	string get_azimuth() {

		return this->azimuth_degrees;
	}

	vector<double> get_normal() //function that -computes- returns the normal vector
	{
		vector<double> normal_vector = { this->normal_vec[0] ,this->normal_vec[1], this->normal_vec[2] };

		return normal_vector;
	}

	double get_doc()
	{
		return this->doc;
	}

	Point get_first_point()
	{
		return this->first_point;
	}

	Point get_second_point()
	{
		return this->second_point;
	}

	Point get_third_point()
	{
		return this->third_point;
	}

	vector<double> get_first_vec() 
	{
		return this->first_vec;
	}

	vector<double> get_second_vec()
	{
		return this->second_vec;
	}
	vector<double> get_third_vec()
	{
		return this->third_vec;
	}

	vector<double> get_directional()
	{
		return this->directional;
	}

	vector<double> get_dip() {

		vector<double> dip_vector = { dip_vec[0],dip_vec[1] ,dip_vec[2] };
		return(dip_vector);
	}
	
	bool get_lin_dependence() {

		return this->lin_dependence;
	}

};




double angle_between_normals(plane plane1, plane plane2) { //a function to calculate angles between a given triangle and neighbor triangles

	double numerator = plane::dot_product(plane1.get_normal(), plane2.get_normal());
	
	if (numerator <= -1.0) {
		return 180;
	}
	else if (numerator >= 1.0) {
		return 0;
	}
	else {
		return acos(numerator) * converter;
	}

}

double euclidean_between_normals(plane plane1, plane plane2) { //a function to calculate angles between a given triangle and neighbor triangles

	vector<double>first_dip = plane1.get_normal();
	vector<double>second_dip = plane2.get_normal(); 
	return sqrt(pow(first_dip[0] - second_dip[0], 2) + pow(first_dip[1] - second_dip[1], 2) + pow(first_dip[2] - second_dip[2], 2));
}

double cosine_distance_between_normals(plane plane1, plane plane2) { //a function to calculate angles between a given triangle and neighbor triangles

	double numerator = plane::dot_product(plane1.get_normal(), plane2.get_normal());
	if (numerator <= -1.0) {
		return 2;
	}
	else if (numerator >= 1.0) {
		return 0;
	}
	else {
		return 1 - numerator;
	}
}

double angle_between_dips(plane plane1, plane plane2) { //a function to calculate angles between a given triangle and neighbor triangles

	double numerator = plane::dot_product(plane1.get_dip(), plane2.get_dip());

	if (numerator <= -1.0) {
		return 180;
	}
	else if (numerator >= 1.0) {
		return 0;
	}
	else {
		return acos(numerator) * converter;
	}
}

double euclidean_between_dip_vectors(plane plane1, plane plane2) { //a function to calculate angles between a given triangle and neighbor triangles

	vector<double>first_dip = plane1.get_dip();
	vector<double>second_dip = plane2.get_dip();
	return sqrt(pow(first_dip[0] - second_dip[0], 2) + pow(first_dip[1] - second_dip[1], 2) + pow(first_dip[2] - second_dip[2], 2));
}

double cosine_distance_between_dips(plane plane1, plane plane2) { //a function to calculate angles between a given triangle and neighbor triangles

	double numerator = plane::dot_product(plane1.get_dip(), plane2.get_dip());
	if (numerator <= -1.0) {
		return 2;
	}
	else if (numerator >= 1.0) {
		return 0;
	}
	else {
		return 1 - numerator;
	}
}

void save_delaunay_vtk(Delaunay dt, vector< std::pair<Point, unsigned> > points_b_inclined_noise_mod, string path) {

	ofstream delaunays(path);

	delaunays <<
		"<?xml version=\"1.0\"?>" << "\n" <<
		"<VTKFile type=\"UnstructuredGrid\" version=\"0.1\" byte_order=\"LittleEndian\" compressor=\"vtkZLibDataCompressor\">" << "\n  " <<
		"<UnstructuredGrid>" << "\n    " <<
		"<Piece NumberOfPoints=\"" << dt.number_of_vertices() << "\" NumberOfCells=\"" << dt.number_of_faces() << "\">" << "\n      "
		"<PointData Scalars=\"scalars\">" << "\n        "
		"<DataArray type=\"Float32\" Name=\"scalars\" format=\"ascii\">" << "\n          ";

	for (auto it = points_b_inclined_noise_mod.begin(); it != points_b_inclined_noise_mod.end(); it++)
	{
		delaunays << fixed << (it->first[2]) << "\n          ";
	}

	delaunays << "\n        " <<
		"</DataArray>" << "\n      " <<
		"</PointData>" << "\n      " <<
		"<Points>" << "\n        " <<
		"<DataArray type=\"Float32\" NumberOfComponents=\"3\" format=\"ascii\">" << "\n           ";

	for (auto it = points_b_inclined_noise_mod.begin(); it != points_b_inclined_noise_mod.end(); it++)
	{
		double x = (it->first[1]), y = (it->first[0]), z = (it->first[2]);
		delaunays << fixed << x << " " << y << " " << z << "\n           ";
	}

	delaunays << "\n        " <<
		"</DataArray>" << "\n      " <<
		"</Points>" << "\n      " <<
		"<Cells>" << "\n        " <<
		"<DataArray type=\"Int32\" Name=\"connectivity\" format=\"ascii\">" << "\n          ";

	for (Delaunay::Finite_faces_iterator fit = dt.finite_faces_begin(); fit != dt.finite_faces_end(); ++fit)
	{
		Delaunay::Face_handle face = fit;
		delaunays << face->vertex(0)->info() - 1 << " " << face->vertex(1)->info() - 1 << " " << face->vertex(2)->info() - 1 << "\n";

		//cout << face->vertex(0)->info() - 1 << " " << face->vertex(1)->info() - 1 << " " << face->vertex(2)->info() - 1 << "\n";
	}

	delaunays << "\n        " <<
		"</DataArray>" << "\n        " <<
		"<DataArray type=\"Int32\" Name=\"offsets\" format=\"ascii\">" << "\n          ";

	for (auto i = 3; i <= 3 * dt.number_of_faces(); i = i + 3)
	{
		delaunays << i << " ";
	}

	delaunays << "\n        " <<
		"</DataArray>" << "\n        " <<
		"<DataArray type=\"UInt8\" Name=\"types\" format=\"ascii\">" <<
		"\n          ";

	for (auto i = 1; i <= dt.number_of_faces(); i++)
	{
		delaunays << 5 << " ";
	}

	delaunays << "\n        " <<
		"</DataArray>" << "\n      " <<
		"</Cells>" << "\n    " <<
		"</Piece>" << "\n  " <<
		"</UnstructuredGrid>" << "\n" <<
		"</VTKFile>";

}


void save_normals_vtk(Delaunay dt, vector< std::pair<Point, unsigned> > points_b_inclined_noise_mod, string path) {


	ofstream normalvis(path);
	std::pair<Point, int> point_1; //we have a pair with point and index of the point
	std::pair<Point, int> point_2;
	std::pair<Point, int> point_3;
	normalvis <<
		"<?xml version=\"1.0\"?>" << "\n" <<
		"<VTKFile type=\"UnstructuredGrid\" version=\"0.1\" byte_order=\"LittleEndian\" compressor=\"vtkZLibDataCompressor\">" << "\n  " <<
		"<UnstructuredGrid>" << "\n    " <<
		"<Piece NumberOfPoints=\"" << dt.number_of_faces() << "\" NumberOfCells=\"" << dt.number_of_faces() << "\">" << "\n      "

		"<PointData Scalars=\"scalars\">" << "\n        "
		"<DataArray type=\"Float32\" Name=\"scalars\" format=\"ascii\">" << "\n          ";


	for (Delaunay::Finite_faces_iterator fit = dt.finite_faces_begin(); fit != dt.finite_faces_end(); ++fit) //a loop for performing the Delaunay triangulation and save the results

	{
		Delaunay::Face_handle face = fit;
		point_1 = make_pair(Point(dt.triangle(face)[0][0], dt.triangle(face)[0][1], dt.triangle(face)[0][2]), face->vertex(0)->info());
		point_2 = make_pair(Point(dt.triangle(face)[1][0], dt.triangle(face)[1][1], dt.triangle(face)[1][2]), face->vertex(1)->info());
		point_3 = make_pair(Point(dt.triangle(face)[2][0], dt.triangle(face)[2][1], dt.triangle(face)[2][2]), face->vertex(2)->info());

		plane current_plane = plane(point_1.first, point_2.first, point_3.first);					//constructing a plane that is processed at the moment
		vector<string> centroid = current_plane.center();		//extracting the centroid of a Delaunay triangle
		normalvis << fixed << centroid[2] << "\n          ";
	}

	normalvis << "\n        " <<
		"</DataArray>" << "\n      " <<
		"</PointData>" << "\n      " <<
		"<Points>" << "\n        " <<
		"<DataArray type=\"Float32\" NumberOfComponents=\"3\" format=\"ascii\">" << "\n           ";

	for (Delaunay::Finite_faces_iterator fit = dt.finite_faces_begin(); fit != dt.finite_faces_end(); ++fit) //a loop for performing the Delaunay triangulation and save the results

	{
		Delaunay::Face_handle face = fit;
		point_1 = make_pair(Point(dt.triangle(face)[0][0], dt.triangle(face)[0][1], dt.triangle(face)[0][2]), face->vertex(0)->info());
		point_2 = make_pair(Point(dt.triangle(face)[1][0], dt.triangle(face)[1][1], dt.triangle(face)[1][2]), face->vertex(1)->info());
		point_3 = make_pair(Point(dt.triangle(face)[2][0], dt.triangle(face)[2][1], dt.triangle(face)[2][2]), face->vertex(2)->info());

		plane current_plane = plane(point_1.first, point_2.first, point_3.first);					//constructing a plane that is processed at the moment
		//string result = current_plane.measure();								//extracting the dip angle and the dip direction
		vector <string> centroid = current_plane.center();

		normalvis << fixed << centroid[1] << " " << centroid[0] << " " << centroid[2] << "\n           ";

	}

	normalvis << "\n        " <<
		"</DataArray>" << "\n      " <<
		"</Points>" << "\n      " <<
		"<Cells>" << "\n        " <<
		"<DataArray type=\"Int32\" Name=\"connectivity\" format=\"ascii\">" << "\n          ";

	for (auto i = 0; i < dt.number_of_faces(); i++)
	{
		normalvis << i << "\n          ";
	}

	normalvis << "\n        " <<
		"</DataArray>" << "\n        " <<
		"<DataArray type=\"Int32\" Name=\"offsets\" format=\"ascii\">" << "\n          ";

	for (auto i = 1; i <= dt.number_of_faces(); i++)
	{
		normalvis << i << " ";
	}

	normalvis << "\n        " <<
		"</DataArray>" << "\n        " <<
		"<DataArray type=\"UInt8\" Name=\"types\" format=\"ascii\">" <<
		"\n          ";

	for (auto i = 1; i <= dt.number_of_faces(); i++)
	{
		normalvis << 1 << " ";
	}

	normalvis << "\n        " <<
		"</DataArray>" << "\n      " <<
		"</Cells>" << "\n    " <<
		"<CellData Normals=\"cell_normals\">" << "\n      " <<
		"<DataArray type=\"Float32\" Name=\"cell_normals\" NumberOfComponents=\"3\" format=\"ascii\">" << "\n          ";


	for (Delaunay::Finite_faces_iterator fit = dt.finite_faces_begin(); fit != dt.finite_faces_end(); ++fit)
	{
		Delaunay::Face_handle face = fit;

		point_1 = make_pair(Point(dt.triangle(face)[0][0], dt.triangle(face)[0][1], dt.triangle(face)[0][2]), face->vertex(0)->info());
		point_2 = make_pair(Point(dt.triangle(face)[1][0], dt.triangle(face)[1][1], dt.triangle(face)[1][2]), face->vertex(1)->info());
		point_3 = make_pair(Point(dt.triangle(face)[2][0], dt.triangle(face)[2][1], dt.triangle(face)[2][2]), face->vertex(2)->info());

		plane current_plane = plane(point_1.first, point_2.first, point_3.first);					//constructing a plane that is processed at the moment
		//string result = current_plane.measure();								//extracting the dip angle and the dip direction
		vector <string> centroid = current_plane.center();		//extracting the centroid of a Delaunay triangle

		double x_n = current_plane.get_normal()[0]; //extracting coordinates of the normal vector of a planar Delaunay triangle
		double y_n = current_plane.get_normal()[1];
		double z_n = current_plane.get_normal()[2];

		normalvis << fixed << y_n << " " << x_n << " " << z_n << "\n          ";
	}

	normalvis <<
		"</DataArray>" << "\n      " <<
		"</CellData>" << "\n      " <<
		"<Cells>" << "\n        " <<
		"</Cells>" << "\n    " <<
		"</Piece>" << "\n  " <<
		"</UnstructuredGrid>" << "\n" <<
		"</VTKFile>";


}


void save_dips_vtk(Delaunay dt, vector< std::pair<Point, unsigned> > points_b_inclined_noise_mod, string path) {


	ofstream dipsvis(path);
	std::pair<Point, int> point_1; //we have a pair with point and index of the point
	std::pair<Point, int> point_2;
	std::pair<Point, int> point_3;
	dipsvis <<
		"<?xml version=\"1.0\"?>" << "\n" <<
		"<VTKFile type=\"UnstructuredGrid\" version=\"0.1\" byte_order=\"LittleEndian\" compressor=\"vtkZLibDataCompressor\">" << "\n  " <<
		"<UnstructuredGrid>" << "\n    " <<
		"<Piece NumberOfPoints=\"" << dt.number_of_faces() << "\" NumberOfCells=\"" << dt.number_of_faces() << "\">" << "\n      "

		"<PointData Scalars=\"scalars\">" << "\n        "
		"<DataArray type=\"Float32\" Name=\"scalars\" format=\"ascii\">" << "\n          ";


	for (Delaunay::Finite_faces_iterator fit = dt.finite_faces_begin(); fit != dt.finite_faces_end(); ++fit) //a loop for performing the Delaunay triangulation and save the results

	{
		Delaunay::Face_handle face = fit;
		point_1 = make_pair(Point(dt.triangle(face)[0][0], dt.triangle(face)[0][1], dt.triangle(face)[0][2]), face->vertex(0)->info());
		point_2 = make_pair(Point(dt.triangle(face)[1][0], dt.triangle(face)[1][1], dt.triangle(face)[1][2]), face->vertex(1)->info());
		point_3 = make_pair(Point(dt.triangle(face)[2][0], dt.triangle(face)[2][1], dt.triangle(face)[2][2]), face->vertex(2)->info());

		plane current_plane = plane(point_1.first, point_2.first, point_3.first);					//constructing a plane that is processed at the moment
		vector<string> centroid = current_plane.center();		//extracting the centroid of a Delaunay triangle
		dipsvis << fixed << centroid[2] << "\n          ";
	}

	dipsvis << "\n        " <<
		"</DataArray>" << "\n      " <<
		"</PointData>" << "\n      " <<
		"<Points>" << "\n        " <<
		"<DataArray type=\"Float32\" NumberOfComponents=\"3\" format=\"ascii\">" << "\n           ";

	for (Delaunay::Finite_faces_iterator fit = dt.finite_faces_begin(); fit != dt.finite_faces_end(); ++fit) //a loop for performing the Delaunay triangulation and save the results

	{
		Delaunay::Face_handle face = fit;
		point_1 = make_pair(Point(dt.triangle(face)[0][0], dt.triangle(face)[0][1], dt.triangle(face)[0][2]), face->vertex(0)->info());
		point_2 = make_pair(Point(dt.triangle(face)[1][0], dt.triangle(face)[1][1], dt.triangle(face)[1][2]), face->vertex(1)->info());
		point_3 = make_pair(Point(dt.triangle(face)[2][0], dt.triangle(face)[2][1], dt.triangle(face)[2][2]), face->vertex(2)->info());

		plane current_plane = plane(point_1.first, point_2.first, point_3.first);					//constructing a plane that is processed at the moment
		//string result = current_plane.measure();								//extracting the dip angle and the dip direction
		vector <string> centroid = current_plane.center();

		dipsvis << fixed << centroid[1] << " " << centroid[0] << " " << centroid[2] << "\n           ";

	}

	dipsvis << "\n        " <<
		"</DataArray>" << "\n      " <<
		"</Points>" << "\n      " <<
		"<Cells>" << "\n        " <<
		"<DataArray type=\"Int32\" Name=\"connectivity\" format=\"ascii\">" << "\n          ";

	for (auto i = 0; i < dt.number_of_faces(); i++)
	{
		dipsvis << i << "\n          ";
	}

	dipsvis << "\n        " <<
		"</DataArray>" << "\n        " <<
		"<DataArray type=\"Int32\" Name=\"offsets\" format=\"ascii\">" << "\n          ";

	for (auto i = 1; i <= dt.number_of_faces(); i++)
	{
		dipsvis << i << " ";
	}

	dipsvis << "\n        " <<
		"</DataArray>" << "\n        " <<
		"<DataArray type=\"UInt8\" Name=\"types\" format=\"ascii\">" <<
		"\n          ";

	for (auto i = 1; i <= dt.number_of_faces(); i++)
	{
		dipsvis << 1 << " ";
	}

	dipsvis << "\n        " <<
		"</DataArray>" << "\n      " <<
		"</Cells>" << "\n    " <<
		"<CellData Normals=\"cell_normals\">" << "\n      " <<
		"<DataArray type=\"Float32\" Name=\"cell_normals\" NumberOfComponents=\"3\" format=\"ascii\">" << "\n          ";


	for (Delaunay::Finite_faces_iterator fit = dt.finite_faces_begin(); fit != dt.finite_faces_end(); ++fit)
	{
		Delaunay::Face_handle face = fit;

		point_1 = make_pair(Point(dt.triangle(face)[0][0], dt.triangle(face)[0][1], dt.triangle(face)[0][2]), face->vertex(0)->info());
		point_2 = make_pair(Point(dt.triangle(face)[1][0], dt.triangle(face)[1][1], dt.triangle(face)[1][2]), face->vertex(1)->info());
		point_3 = make_pair(Point(dt.triangle(face)[2][0], dt.triangle(face)[2][1], dt.triangle(face)[2][2]), face->vertex(2)->info());

		plane current_plane = plane(point_1.first, point_2.first, point_3.first);					//constructing a plane that is processed at the moment
								//extracting the dip angle and the dip direction
		vector <string> centroid = current_plane.center();		//extracting the centroid of a Delaunay triangle

		double x_d = current_plane.get_dip()[0]; //extracting coordinates of the dip vector of a planar Delaunay triangle
		double y_d = current_plane.get_dip()[1];
		double z_d = current_plane.get_dip()[2];

		vector<double> dip_vector_double = { x_d, y_d, z_d };
		dipsvis << fixed << y_d << " " << x_d << " " << z_d << "\n          ";
	}

	dipsvis <<
		"</DataArray>" << "\n      " <<
		"</CellData>" << "\n      " <<
		"<Cells>" << "\n        " <<
		"</Cells>" << "\n    " <<
		"</Piece>" << "\n  " <<
		"</UnstructuredGrid>" << "\n" <<
		"</VTKFile>";
}

void save_model_parameters(string path_params,
	int number_of_files, //number of files generated
	int left_terrain_size, int right_terrain_size, //lower and upper bound for the set of terrain sizes
	int left_range_azimuth, int right_range_azimuth, //for azimuth
	double min_terrain_dip, double max_terrain_dip, //for the dip 
	int left_number_triangulation, int right_number_triangulation, // lower and upper bound for the number of points in the triangulation
	double left_surface_noise, double right_surface_noise, // bounds for the noise introduced to the surface
	double left_fault_throw, double right_fault_throw, //bounds for the values of fault throw	
	vector <std::pair<double, double>> orientation) {

	ofstream save_params(path_params);

	save_params << "Number of files: " << number_of_files << "\n" <<
		"Left terrain size: " << left_terrain_size << "\n" <<
		"Right terrain size: " << right_terrain_size << "\n" <<
		"Left range azimuth given: " << left_range_azimuth << "\n" <<
		"Right range azimuth given: " << right_range_azimuth << "\n" <<
		"Minimum dip given: " << min_terrain_dip << "\n" <<
		"Maximum dip terrain given: " << max_terrain_dip << "\n" <<
		"Lower bound for points in the triangulation: " << left_number_triangulation << "\n" <<
		"Upper bound for points in the triangulation: " << right_number_triangulation << "\n" <<
		"Lower bound for noise: " << left_surface_noise << "\n" <<
		"Upper bound for noise: " << right_surface_noise << "\n" <<
		"Lower bound for fault throw: " << left_fault_throw << "\n" <<
		"Upper bound for fault throw: " << right_fault_throw;

	save_params << endl;
	save_params << "Orientations are as follows:" << endl;
	for (int i = 0; i != number_of_files; ++i) {

		save_params << "For the " << to_string(i) << "-file we have:  " "Dip ang: " << orientation.at(i).first << ".  Dip direction: " << orientation.at(i).second << "." << endl;

	}
}

int main()
{
	std::random_device rd;
	std::default_random_engine re(rd());

	int number_of_files; //number of files generated
	int left_terrain_size, right_terrain_size; //lower and upper bound for the set of terrain sizes
	int left_range_azimuth, right_range_azimuth; //for azimuth
	double min_terrain_dip, max_terrain_dip; //for the dip 
	int left_number_triangulation, right_number_triangulation; // lower and upper bound for the number of points in the triangulation
	double left_surface_noise, right_surface_noise; // bounds for the noise introduced to the surface
	double left_fault_throw, right_fault_throw; //bounds for the values of fault throw



	std::cout << "This is generator of faulted triangulated surfaces. We need to introduce some parameters." << std::endl;
	std::cout << "How many files (terrains) do you want?" << endl;
	std::cin >> number_of_files;
	if (number_of_files < 0) throw runtime_error("s");
	std::cout << "There are " << number_of_files << " files" << endl;
	std::cout << "If the size of the terrain should not be constant, specify different bounds ({left_terrain_size,...,right_terrain_size})" << std::endl;
	std::cin >> left_terrain_size >> right_terrain_size;
	if (left_terrain_size < 0) throw runtime_error("s");
	cout << "The terrain sizes will be randomly selected from the set: {" << left_terrain_size << ",...," << right_terrain_size << "}" << endl;
	std::uniform_int_distribution<int> random_terrain_size(left_terrain_size, right_terrain_size);
	std::cout << "Specify minimum and maximum value of dip for the terrain." << endl;
	std::cin >> min_terrain_dip >> max_terrain_dip;
	if (min_terrain_dip < 0) throw runtime_error("s");
	cout << "The minimum dip is: " << min_terrain_dip << ". And the maximum dip is: " << max_terrain_dip << endl;
if (max_terrain_dip > 90) throw runtime_error("s");
	std::uniform_real_distribution<double> random_dip(min_terrain_dip, max_terrain_dip);
	std::cout << "Specify directional range for the azimuth. For example, if all azimuth should be considered, enter 0 and 360." << endl;
	std::cin >> left_range_azimuth >> right_range_azimuth; 
	if (left_range_azimuth < 0) throw runtime_error("s");
	if (right_range_azimuth < 0) throw runtime_error("s");
	if (right_range_azimuth < left_range_azimuth) {
		right_range_azimuth += 360;
	}
	std::cout << "The left bound of azimuth is: " << left_range_azimuth << ". And the right bound for azimuth is: " << right_range_azimuth << endl;
	std::uniform_int_distribution<int> random_azimuth(left_range_azimuth, right_range_azimuth);
	std::cout << "If the number of points in the terrain should not be constant, specify different bounds ({left_number_triangulation,...,right_number_triangulation})" << endl;
	std::cin >> left_number_triangulation >> right_number_triangulation;
	if (left_number_triangulation < 3) throw runtime_error("s");
	cout << "The lower bound for points in the triangulation is: " << left_number_triangulation << ". And the upper bound for points in the triangulation is: " << right_number_triangulation << endl;
	std::uniform_int_distribution<int> random_points_triangulation(left_number_triangulation, right_number_triangulation);
	std::cout << "Specify lower and upper bound of noise introduced to the surface (typically below 0.1)" << endl;
	cin >> left_surface_noise >> right_surface_noise;
	if (left_surface_noise>1) throw runtime_error("s");
	if (right_surface_noise > 1) throw runtime_error("s");
	std::cout << "The lower bound for noise is: " << left_surface_noise << " . And the upper bound for surface noise is:" << right_surface_noise << endl;
	std::uniform_real_distribution<double> surface_unif(left_surface_noise, right_surface_noise);
	std::cout << "What are the lower and upper bounds for fault throw?" << endl;

	cin >> left_fault_throw >> right_fault_throw;
	if (left_fault_throw > 1) throw runtime_error("s");
	if (right_fault_throw > 1) throw runtime_error("s");
	std::cout << "The lower bound for fault throw: " << left_fault_throw << " . And the upper bound for fault throw:" << right_fault_throw << endl;
	std::uniform_real_distribution<double> fault_unif(left_fault_throw, right_fault_throw); //determines the 
	std::cout << "The files are being generated... \n" << endl;

	/*the data below are needed for simulating fault throws in the surface. We assume
that the upper bound for fault throw depends on the maximum dip angle in the data set.
 We want to consider the maximum throw as a fraction of the elevation difference between the maximum possible dip in the data set.
 Therefore, we specify a plane dipping to N with maximum dip.
 We know that the points are sampled from a square centered at (0,0) and the corner coordinates (a,a), where "a" is the argument of the sampling function.
 Therefore, without losing generality, we can consider points with coordinates (a,0) and (-a,0).
 The distance between these points is 2a.
 We calculate a normal vector to the surface.
 From the coordinates of the normal vector, we can derive elevation (Z) coordinates for points (a,0) and (-a,0).
*/
	int user_dip_direction = 0;
	double user_dip_angle = max_terrain_dip;
	double n_max_x = -sin(user_dip_angle / converter) * cos(user_dip_direction / converter);
	double n_max_z = -cos(user_dip_angle / converter);
	double max_elev_diff = 2 * right_terrain_size * abs(n_max_x / n_max_z);



	vector <int> sample_dipdir; //the surfaces will have a random dip dir and random dip direction
	vector <double> sample_dipang;

	vector <std::pair<double, double>> orientation;
	for (int i = 0; i < number_of_files; i++) { //sample values of dip direction
		sample_dipdir.push_back(random_azimuth(re)); //random_azimuth(re)
	}

	for (int i = 0; i < number_of_files; i++) { //sample values of dip angle - because we have a terrain, we have a maximum limit for dip angle
		sample_dipang.push_back(random_dip(re)); //random_dip(re)
		//assert(sample_dipang[i] == 1);
	}

	for (int i = 0; i < number_of_files; i++) { //sample orientation
		orientation.push_back(make_pair(sample_dipang[i], sample_dipdir[i]));
	}



	vector <vector<double>>  poles;
	vector <double> triplet;
	cout << "Tests: " << endl;
	for (int i = 0; i < number_of_files; i++) {
		double x = -sin(orientation[i].first / converter) * cos(orientation[i].second / converter);
		double y = -sin(orientation[i].first / converter) * sin(orientation[i].second / converter);
		double z = -cos(orientation[i].first / converter);

		if (z < 0) {
			x = x * -1;
			y = y * -1;
			z = z * -1;
		}
		//The below code tests whether the orientations specified by the user are converted correctly into XYZ coordinates and can be back-transformed into orientations
		/*
		double help_azimuth = (atan2(y, x) * converter);
		cout << "Back-transformed dip direction: " << fixed << (help_azimuth>0 ?  help_azimuth: (help_azimuth + 360)) << endl;
		cout << "Back-transformed dipangle: " << fixed << acos(z) * converter << endl;
		cout << "Normal vector of the surface, as given by a user: " << fixed << x << " " << y << " " << z << endl;
		*/

		double help_azimuth = (atan2(y, x) * converter);
		if (help_azimuth < 0) {
			help_azimuth += 360;
		}
		double help_dip_ang = acos(z) * converter;
		cout << "Back-converted azimuth: " << help_azimuth << " " << "Original azimuth: " << orientation[i].second << endl;
		cout << "Back-converted dip angle: " << help_dip_ang << " " << "Original dip angle: " << orientation[i].first << endl;
		triplet.push_back(x);
		triplet.push_back(y);
		triplet.push_back(z);

		poles.push_back(triplet);
		triplet.clear();
	}

	string path_params = "C:\\testy\\scikit7\\params.txt";
	save_model_parameters(
		path_params,
		number_of_files, //number of files generated
		left_terrain_size, right_terrain_size, //lower and upper bound for the set of terrain sizes
		left_range_azimuth, right_range_azimuth, //for azimuth
		min_terrain_dip, max_terrain_dip, //for the dip 
		left_number_triangulation, right_number_triangulation, // lower and upper bound for the number of points in the triangulation
		left_surface_noise, right_surface_noise, // bounds for the noise introduced to the surface
		left_fault_throw, right_fault_throw, //bounds for the values of fault throw	
		orientation);

	int i = 0; //name or number of the file

	while (i < number_of_files)
	{
		string file_path = "C:\\testy\\scikit7\\";
		file_path.append(to_string(i));
		file_path.append(".txt");

		ofstream saving(file_path);
		saving <<
			"Dip_angle;" << "Dip_direction;" <<
			"X_C;" << "Y_C;" << "Z_C;" <<
			"X_N;" << "Y_N;" << "Z_N;" <<
			"X_D;" << "Y_D;" << "Z_D;" <<
			"X_C_Neighbor1;" << "Y_C_Neighbor1;" << "Z_C_Neighbor1;" <<
			"X_C_Neighbor2;" << "Y_C_Neighbor2;" << "Z_C_Neighbor2;" <<
			"X_C_Neighbor3;" << "Y_C_Neighbor3;" << "Z_C_Neighbor3;" <<

			"EuclideanNeighbor1_N;" << "EuclideanNeighbor2_N;" << "EuclideanNeighbor3_N;" <<
			"AngleNeighbor1_N;" << "AngleNeighbor2_N;" << "AngleNeighbor3_N;" <<
			"CosineNeighbor1_N;" << "CosineNeighbor2_N;" << "CosineNeighbor3_N;" <<


			"EuclideanNeighbor1_D;" << "EuclideanNeighbor2_D;" << "EuclideanNeighbor3_D;" <<
			"AngleNeighbor1_D;" << "AngleNeighbor2_D;" << "AngleNeighbor3_D;" <<
			"CosineNeighbor1_D;" << "CosineNeighbor2_D;" << "CosineNeighbor3_D;" <<


			"n1_xn;" << "n1_yn;" << "n1_zn;" <<
			"n2_xn;" << "n2_yn;" << "n2_zn;" <<
			"n3_xn;" << "n3_yn;" << "n3_zn;" <<
			"n1_xd;" << "n1_yd;" << "n1_zd;" <<
			"n2_xd;" << "n2_yd;" << "n2_zd;" <<
			"n3_xd;" << "n3_yd;" << "n3_zd;" <<
			"File_number;" <<
			"IDT1;" << "IDT2;" << "IDT3;" <<
			"Fault;" << "DOC;" << "help_dot_productnormals" << endl;


		vector<Point_2> points_f; //vector for storing fault lines

		Point_o_generator f(random_terrain_size(re)); // faults (f), argument denotes the size of a square, the points representing a fault line lie on the boundary of the square, because we have an outside generator

		std::copy_n(f, 2, back_inserter(points_f));

		if ((points_f[0].x() == points_f[1].x()) || (points_f[0].y() == points_f[1].y())) { //we don't want ideally vertical or horizontal fault lines, because in extreme cases (if the fault line lies on the boundary), all points from the domain would have the same label
			double x3 = points_f[0].x();
			double y3 = points_f[0].y();

			points_f.erase(points_f.begin());
			points_f.insert(points_f.begin(), Point_2(y3, x3));
		}


		vector<Point_2> points_b; //vector for storing boreholes/points
		Point_i_generator b(random_terrain_size(re)); // boreholes (b), argument denotes the size of a square, adding 100 points inside (because we have an inside generator)

		std::copy_n(b, random_points_triangulation(re), back_inserter(points_b));

		vector<Point> points_b_inclined; //we must add elevation

		for (auto it = points_b.begin(); it != points_b.end(); it++) {
			//The test in this loop shows coordinates of normal vectors representing the surfaces
			//cout << "1st (x):   " << poles[i][0] << "  2nd(y): " << poles[i][1] << "  3rd(z): " << poles[i][2] << endl;
			points_b_inclined.push_back(Point((*it).x(), (*it).y(), (- poles[i][0] * (*it).x() - poles[i][1] * (*it).y())/poles[i][2] )); // z=(-2x-3y)/4, web.me.utexas.edu, find an equation for the plane passing through the point Q(0,0,0) and parallel to the plane 2x+3y+4z=5
		}
		cout << 
			"p1: " << points_b_inclined[2] << "\n" <<
			"p2: " << points_b_inclined[5] << "\n" <<
			"p3: " << points_b_inclined[19] << "\n";

		plane plane1= plane(points_b_inclined[2], points_b_inclined[5], points_b_inclined[19]);
		string dip_inclined = plane1.get_dip_angle(); 
		string azimuth_inclined = plane1.get_azimuth();
		cout << "Dip angle of inclined:  " << dip_inclined << std::endl;
		cout << "Azimuth of the inclined:  " << azimuth_inclined << std::endl;
		cout << "Normal vector of an inclined:  " << plane1.get_normal().at(0) << "  " << plane(points_b_inclined[2], points_b_inclined[5], points_b_inclined[19]).get_normal().at(1) << " " << plane(points_b_inclined[2], points_b_inclined[5], points_b_inclined[19]).get_normal().at(2) << std::endl;
		cout << "Length of the normal of the inclined: " <<  plane::length( plane1.get_normal())  << endl;
       
	//Comparison: The lambda function[](const Point& point1, const Point& point2) { return (point1.z() < point2.z()); }
	//	tells max_element how to compare two Point objects. It compares them based on their z values.
		auto& greatest_elev = *max_element(points_b_inclined.begin(), points_b_inclined.end(),
			[](const Point& point1, const Point& point2) { return (point1.z() < point2.z()); }
		);
		auto& smallest_elev = *min_element(points_b_inclined.begin(), points_b_inclined.end(),
			[](const Point& point1, const Point& point2) { return (point1.z() < point2.z()); }
		);

		auto elevation_difference = greatest_elev.z() - smallest_elev.z(); //elevation difference is calculated for each terrain seperately
		auto value_of_fault_throw = fault_unif(re) * max_elev_diff; //fault throws are generated; for example 1.1547 is the maximum elevation difference between points on a terrain with maximum dip=30 with size 1, (it has a normal vector [-0.5,0,-0.86], therefore 1*Z=-0.5/0.86=-0.57735, 2*1(size)*-0.57735=1.1547)

		vector<Point> points_b_inclined_noise; //we must add noise to elevation

		for (auto it = points_b_inclined.begin(); it != points_b_inclined.end(); it++) {
			points_b_inclined_noise.push_back(Point((*it).x(), (*it).y(), (*it).z() + elevation_difference * surface_unif(re))); // 
		}

		vector< std::pair<Point, unsigned> > points_b_inclined_noise_mod;//this data structure is necessary for VTK visualization, an integer must be added to represent each point in the VTK structure
		auto number_of_point = 1; //necessary for VTK visualization
		for (auto it = points_b_inclined_noise.begin(); it != points_b_inclined_noise.end(); it++)
		{

			switch (CGAL::orientation(
				Point_2(points_f[0].x(), points_f[0].y()),
				Point_2(points_f[1].x(), points_f[1].y()),
				Point_2((*it).x(), (*it).y()))
				)
			{
			case CGAL::LEFT_TURN:
				points_b_inclined_noise_mod.push_back(make_pair(Point((*it).x(), (*it).y(), (*it).z() - value_of_fault_throw), number_of_point)); break;
			case CGAL::RIGHT_TURN:
				points_b_inclined_noise_mod.push_back(make_pair(Point((*it).x(), (*it).y(), (*it).z()), number_of_point)); break;
			case CGAL::COLLINEAR:
				points_b_inclined_noise_mod.push_back(make_pair(Point((*it).x(), (*it).y(), -9999999), number_of_point)); break;
			}
			number_of_point++;
		}

		Delaunay dt;

		dt.insert(points_b_inclined_noise_mod.begin(), points_b_inclined_noise_mod.end());
		vector <plane> planes; //a vector variable storing planes representing the second surface
		std::pair<Point, int> point_1; //we have a pair with point and index of the point
		std::pair<Point, int> point_2;
		std::pair<Point, int> point_3;

		Point n1_point_1; //three coordinates: XYZ of neighbors
		Point n1_point_2;
		Point n1_point_3;

		Point n2_point_1;
		Point n2_point_2;
		Point n2_point_3;

		Point n3_point_1;
		Point n3_point_2;
		Point n3_point_3;


		Kernel::Line_2 f1(Point_2(points_f[0].x(), points_f[0].y()), Point_2(points_f[1].x(), points_f[1].y())); //creating one fault line


		for (Delaunay::Finite_faces_iterator fit = dt.finite_faces_begin(); fit != dt.finite_faces_end(); ++fit) //a loop for performing the Delaunay triangulation and save the results

		{
			Delaunay::Face_handle face = fit;
			point_1 = make_pair(Point(dt.triangle(face)[0][0], dt.triangle(face)[0][1], dt.triangle(face)[0][2]), face->vertex(0)->info());
			point_2 = make_pair(Point(dt.triangle(face)[1][0], dt.triangle(face)[1][1], dt.triangle(face)[1][2]), face->vertex(1)->info());
			point_3 = make_pair(Point(dt.triangle(face)[2][0], dt.triangle(face)[2][1], dt.triangle(face)[2][2]), face->vertex(2)->info());

			try {
				planes.push_back(plane(point_1.first, point_2.first, point_3.first));
			}
			catch (exception e) {

				cout << e.what() << endl;
			}


			Point_2 t1(dt.triangle(face)[0][0], //extracting coordinates of points building a Delaunay triangle
				dt.triangle(face)[0][1]);

			Point_2 t2(dt.triangle(face)[1][0],
				dt.triangle(face)[1][1]);

			Point_2 t3(dt.triangle(face)[2][0],
				dt.triangle(face)[2][1]);



			plane current_plane = plane(point_1.first, point_2.first, point_3.first);					//constructing a plane that is processed at the moment
			//string result = current_plane.measure();								//extracting the dip angle and the dip direction
			vector<string> centroid = current_plane.center();		//extracting the centroid of a Delaunay triangle

			double x_n = current_plane.get_normal()[0]; //extracting coordinates of the normal vector of a planar Delaunay triangle
			double y_n = current_plane.get_normal()[1];
			double z_n = current_plane.get_normal()[2];



			double x_d = current_plane.get_dip()[0]; //extracting coordinates of the dip vector of a planar Delaunay triangle
			double y_d = current_plane.get_dip()[1];
			double z_d = current_plane.get_dip()[2];

			//Normal vectors of neighbors

			double n1_x_n; //extracting coordinates of the normal vector of a planar Delaunay triangle
			double n1_y_n;
			double n1_z_n;

			double n2_x_n;//extracting coordinates of the normal vector of a planar Delaunay triangle
			double n2_y_n;
			double n2_z_n;

			double n3_x_n; //extracting coordinates of the normal vector of a planar Delaunay triangle
			double n3_y_n;
			double n3_z_n;

			//Dip vectors of neighbors
			double d1_x_d; //extracting coordinates of the dip vector of a planar Delaunay triangle
			double d1_y_d;
			double d1_z_d;

			double d2_x_d;//extracting coordinates of the dip vector of a planar Delaunay triangle
			double d2_y_d;
			double d2_z_d;

			double d3_x_d; //extracting coordinates of the dip vector of a planar Delaunay triangle
			double d3_y_d;
			double d3_z_d;


			//1st neighbor
			double n_euclidean1 = -9999;
			double n_angle1 = -9999;
			double n_cos1 = -9999;
			double d_euclidean1 = -9999;
			double d_angle1 = -9999;
			double d_cos1 = -9999;
			vector<string> centroid_n1;

			if (dt.is_infinite(face->neighbor(0)) == true) {


				n1_x_n = -9999; //fake coordinates for normal vectors of the infinite neighbor
				n1_y_n = -9999;
				n1_z_n = -9999;
				d1_x_d = -9999; //fake coordinates for dip vectors of the infinite neighbor
				d1_y_d = -9999;
				d1_z_d = -9999;
				centroid_n1.push_back("undefined");
				centroid_n1.push_back("undefined");
				centroid_n1.push_back("undefined");
				//n_euclidean1, n_angle1, n_cos1, n_euclidean1, d_angle1, d_cos1 = -9999;
			}
			else {
				n1_point_1 = Point(dt.triangle(face->neighbor(0))[0][0], dt.triangle(face->neighbor(0))[0][1], dt.triangle(face->neighbor(0))[0][2]);


				n1_point_2 = Point(dt.triangle(face->neighbor(0))[1][0], dt.triangle(face->neighbor(0))[1][1], dt.triangle(face->neighbor(0))[1][2]);


				n1_point_3 = Point(dt.triangle(face->neighbor(0))[2][0], dt.triangle(face->neighbor(0))[2][1], dt.triangle(face->neighbor(0))[2][2]);

				plane neighbor1_plane = plane(n1_point_1, n1_point_2, n1_point_3);
				n1_x_n = neighbor1_plane.get_normal()[0];// / plane::length(neighbor1_plane.get_normal()); //extracting coordinates of the normal vector of a planar Delaunay triangle
				n1_y_n = neighbor1_plane.get_normal()[1]; /// plane::length(neighbor1_plane.get_normal());
				n1_z_n = neighbor1_plane.get_normal()[2]; /// plane::length(neighbor1_plane.get_normal());

				d1_x_d = neighbor1_plane.get_dip()[0]; // plane::length(neighbor1_plane.get_dip()); //fake coordinates for dip vectors of the infinite neighbor
				d1_y_d = neighbor1_plane.get_dip()[1]; // plane::length(neighbor1_plane.get_dip());
				d1_z_d = neighbor1_plane.get_dip()[2]; // plane::length(neighbor1_plane.get_dip());


				centroid_n1 = neighbor1_plane.center();


				n_euclidean1 = euclidean_between_normals(current_plane, neighbor1_plane);
				//assert(n_euclidean1 < 0.001);

				n_angle1 = angle_between_normals(current_plane, neighbor1_plane);
				n_cos1 = cosine_distance_between_normals(current_plane, neighbor1_plane);

				d_euclidean1 = euclidean_between_dip_vectors(current_plane, neighbor1_plane);
				d_angle1 = angle_between_dips(current_plane, neighbor1_plane);
				d_cos1 = cosine_distance_between_dips(current_plane, neighbor1_plane);
			}


			//2nd neighbor
			double n_euclidean2 = -9999;
			double n_angle2 = -9999;
			double n_cos2 = -9999;
			double d_euclidean2 = -9999;
			double d_angle2 = -9999;
			double d_cos2 = -9999;
			vector<string> centroid_n2;


			if (dt.is_infinite(face->neighbor(1)) == true) {


				n2_x_n = -9999; //fake coordinates for normal vectors of the infinite neighbor
				n2_y_n = -9999;
				n2_z_n = -9999;


				d2_x_d = -9999; //fake coordinates for dip vectors of the infinite neighbor
				d2_y_d = -9999;
				d2_z_d = -9999;
				centroid_n2.push_back("undefined");
				centroid_n2.push_back("undefined");
				centroid_n2.push_back("undefined");
				//n_euclidean2, n_angle2, n_cos2, n_euclidean2, d_angle2, d_cos2= -9999;
			}
			else {
				n2_point_1 = Point(dt.triangle(face->neighbor(1))[0][0], dt.triangle(face->neighbor(1))[0][1], dt.triangle(face->neighbor(1))[0][2]);


				n2_point_2 = Point(dt.triangle(face->neighbor(1))[1][0], dt.triangle(face->neighbor(1))[1][1], dt.triangle(face->neighbor(1))[1][2]);


				n2_point_3 = Point(dt.triangle(face->neighbor(1))[2][0], dt.triangle(face->neighbor(1))[2][1], dt.triangle(face->neighbor(1))[2][2]);


				plane neighbor2_plane = plane(n2_point_1, n2_point_2, n2_point_3);

				n2_x_n = neighbor2_plane.get_normal()[0]; // plane::length(neighbor2_plane.get_normal()); //extracting coordinates of the normal vector of a planar Delaunay triangle
				n2_y_n = neighbor2_plane.get_normal()[1]; // plane::length(neighbor2_plane.get_normal());
				n2_z_n = neighbor2_plane.get_normal()[2]; // plane::length(neighbor2_plane.get_normal());

				d2_x_d = neighbor2_plane.get_dip()[0]; // plane::length(neighbor2_plane.get_dip()); //fake coordinates for dip vectors of the infinite neighbor
				d2_y_d = neighbor2_plane.get_dip()[1]; // plane::length(neighbor2_plane.get_dip());
				d2_z_d = neighbor2_plane.get_dip()[2]; // plane::length(neighbor2_plane.get_dip());

				centroid_n2 = neighbor2_plane.center();


				n_euclidean2 = euclidean_between_normals(current_plane, neighbor2_plane);
				//assert(n_euclidean2 < 0.001);
				n_angle2 = angle_between_normals(current_plane, neighbor2_plane);
				n_cos2 = cosine_distance_between_normals(current_plane, neighbor2_plane);

				d_euclidean2 = euclidean_between_dip_vectors(current_plane, neighbor2_plane);
				d_angle2 = angle_between_dips(current_plane, neighbor2_plane);
				d_cos2 = cosine_distance_between_dips(current_plane, neighbor2_plane);
			}


			//3 neighbor

			double n_euclidean3 = -9999;
			double n_angle3 = -9999;
			double n_cos3 = -9999;
			double d_euclidean3 = -9999;
			double d_angle3 = -9999;
			double  d_cos3 = -9999;
			vector<string> centroid_n3;


			if (dt.is_infinite(face->neighbor(2)) == true) {

				n3_x_n = -9999; //fake coordinates for normal vectors of the infinite neighbor
				n3_y_n = -9999;
				n3_z_n = -9999;

				d3_x_d = -9999; //fake coordinates for dip vectors of the infinite neighbor
				d3_y_d = -9999;
				d3_z_d = -9999;

				centroid_n3.push_back("undefined");
				centroid_n3.push_back("undefined");
				centroid_n3.push_back("undefined");

			}
			else {
				n3_point_1 = Point(dt.triangle(face->neighbor(2))[0][0], dt.triangle(face->neighbor(2))[0][1], dt.triangle(face->neighbor(2))[0][2]);

				n3_point_2 = Point(dt.triangle(face->neighbor(2))[1][0], dt.triangle(face->neighbor(2))[1][1], dt.triangle(face->neighbor(2))[1][2]);

				n3_point_3 = Point(dt.triangle(face->neighbor(2))[2][0], dt.triangle(face->neighbor(2))[2][1], dt.triangle(face->neighbor(2))[2][2]);


				plane neighbor3_plane = plane(n3_point_1, n3_point_2, n3_point_3);

				n3_x_n = neighbor3_plane.get_normal()[0]; // plane::length(neighbor3_plane.get_normal()); //extracting coordinates of the normal vector of a planar Delaunay triangle
				n3_y_n = neighbor3_plane.get_normal()[1]; // plane::length(neighbor3_plane.get_normal());
				n3_z_n = neighbor3_plane.get_normal()[2]; /// plane::length(neighbor3_plane.get_normal());

				centroid_n3 = neighbor3_plane.center();


				d3_x_d = neighbor3_plane.get_dip()[0]; // plane::length(neighbor3_plane.get_dip()); //fake coordinates for dip vectors of the infinite neighbor
				d3_y_d = neighbor3_plane.get_dip()[1]; // plane::length(neighbor3_plane.get_dip());
				d3_z_d = neighbor3_plane.get_dip()[2]; // plane::length(neighbor3_plane.get_dip());

				n_euclidean3 = euclidean_between_normals(current_plane, neighbor3_plane);
				//assert(n_euclidean3 < 0.001);
				n_angle3 = angle_between_normals(current_plane, neighbor3_plane);
				n_cos3 = cosine_distance_between_normals(current_plane, neighbor3_plane);

				d_euclidean3 = euclidean_between_dip_vectors(current_plane, neighbor3_plane);
				d_angle3 = angle_between_dips(current_plane, neighbor3_plane);
				d_cos3 = cosine_distance_between_dips(current_plane, neighbor3_plane);
			}


			bool intersect = CGAL::do_intersect(Kernel::Triangle_2(t1, t2, t3), f1);
			int intersect_label = (intersect == true ? 1 : -1);

			// assert(stoi(current_plane.get_dip_angle()) ==  1 );

			saving <<
				current_plane.get_dip_angle() << ";" <<
				current_plane.get_azimuth() << ";" <<
				centroid[0] << ";" <<
				centroid[1] << ";" <<
				centroid[2] << ";" <<
				x_n << ";" << y_n << ";" << z_n << ";" <<
				x_d << ";" << y_d << ";" << z_d << ";" <<
				centroid_n1[0] << ";" << centroid_n1[1] << ";" << centroid_n1[2] << ";" <<
				centroid_n2[0] << ";" << centroid_n2[1] << ";" << centroid_n2[2] << ";" <<
				centroid_n3[0] << ";" << centroid_n3[1] << ";" << centroid_n3[2] << ";" <<

				n_euclidean1 << ";" << n_euclidean2 << ";" << n_euclidean3 << ";" <<
				n_angle1 << ";" << n_angle2 << ";" << n_angle3 << ";" <<
				n_cos1 << ";" << n_cos2 << ";" << n_cos3 << ";" <<

				d_euclidean1 << ";" << d_euclidean2 << ";" << d_euclidean3 << ";" <<
				d_angle1 << ";" << d_angle2 << ";" << d_angle3 << ";" <<
				d_cos1 << ";" << d_cos2 << ";" << d_cos3 << ";" <<


				n1_x_n << ";" << n1_y_n << ";" << n1_z_n << ";" <<
				n2_x_n << ";" << n2_y_n << ";" << n2_z_n << ";" <<
				n3_x_n << ";" << n3_y_n << ";" << n3_z_n << ";" <<
				d1_x_d << ";" << d1_y_d << ";" << d1_z_d << ";" <<
				d2_x_d << ";" << d2_y_d << ";" << d2_z_d << ";" <<
				d3_x_d << ";" << d3_y_d << ";" << d3_z_d << ";" <<
				i << ";" <<
				face->vertex(0)->info() << ";" << //id start
				face->vertex(1)->info() << ";" <<
				face->vertex(2)->info() << ";" << //id end
				intersect_label << ";" << current_plane.get_doc() << ";" 
				<<  plane::dot_product(current_plane.get_normal(), plane::plane(n1_point_1, n1_point_2, n1_point_3).get_normal()) //three coordinates: XYZ of neighbors ;
				<< endl;

		}

		string file_path_del = "C:\\testy\\scikit7\\";
		file_path_del.append(to_string(i) + "_delaunay.vtu");
		string file_path_nor = "C:\\testy\\scikit7\\";
		file_path_nor.append(to_string(i) + "_normals.vtu");
		string file_path_dips = "C:\\testy\\scikit7\\";
		file_path_dips.append(to_string(i) + "_dips.vtu");

		save_delaunay_vtk(dt, points_b_inclined_noise_mod, file_path_del);
		save_normals_vtk(dt, points_b_inclined_noise_mod, file_path_nor);
		save_dips_vtk(dt, points_b_inclined_noise_mod, file_path_dips);

		i++;
	}

	system("pause");
	return 0;
}
